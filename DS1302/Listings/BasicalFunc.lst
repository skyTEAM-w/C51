C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BASICALFUNC
OBJECT MODULE PLACED IN .\Objects\BasicalFunc.obj
COMPILER INVOKED BY: D:\Program files\Keil\C51\BIN\C51.EXE BasicalFunc.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\BasicalFunc.lst) TABS(2) OBJECT(.\Objects\BasicalFunc.obj)

line level    source

   1          /**
   2           * @file BasicalFunc.c
   3           * @author WuChengpei_Sky (w2563070231@outlook.com)
   4           * @brief 人人卓越工程51单片机常用函数库的实现
   5           * @version 1.2
   6           * @date 2022-01-11
   7           *
   8           * @copyright Copyright (c) 2022
   9           *
  10           */
  11          
  12          #include <REGX52.H>
  13          // #include <NomalFunc.h>
  14          
  15          /*---------------------------------------
  16          Delay
  17          ---------------------------------------*/
  18          
  19          /**
  20           * @brief 延时X毫秒
  21           *
  22           * @param X_ms 延迟的毫秒数
  23           * @retval 无
  24           */
  25          void Delay(unsigned int X_ms) //@12.000MHz
  26          {
  27   1          unsigned char i, j;
  28   1          while (X_ms--)
  29   1          {
  30   2              /* code */
  31   2              i = 2;
  32   2              j = 239;
  33   2              do
  34   2              {
  35   3                  while (--j)
  36   3                      ;
  37   3              } while (--i);
  38   2          }
  39   1      }
  40          
  41          /*---------------------------------------
  42          SEG Tube
  43          ---------------------------------------*/
  44          unsigned char code SEGNum[] = {
  45              0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07,
  46              0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71,
  47              0x00}; // Make an Arry to save the one's complement of SEG
  48          
  49          unsigned char code SEGSign[] = {
  50              0x7F, 0xBF
  51          };
  52          
  53          /**
  54           * @brief 数码管显示数字
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 2   

  55           *
  56           * @param Location 显示位置
  57           * @param Number 显示的数字
  58           * @retval 无
  59           */
  60          void SEG(unsigned char Location, unsigned char Number)
  61          { // Use SEG Tube Show Setted Number
  62   1          P1 = ~(0x01 << (8 - Location));
  63   1          P0 = ~SEGNum[Number];
  64   1          Delay(1);
  65   1          P0 = 0xFF;
  66   1      }
  67          
  68          /**
  69           * @brief 数码管扫描函数，最大可在数码管中显示0~65535范围内的整数。
  70           * 格式：右对齐
  71           * 
  72           * @param Data 显示的数据 范围：
  73           * L_MODE与R_MODE：0~9999
  74           * N_MODE:0~65535
  75           * @param ScanMode 输出模式：
  76           * 'L''l'：左侧数码管输出
  77           * 'R''r'：右侧数码管输出
  78           * 'N''n'：双侧数码管共同输出
  79           */
  80          void SEGScan(unsigned int Data, char ScanMode)
  81          {
  82   1          unsigned char TempData[8];
  83   1          int count = 0;
  84   1          switch (ScanMode)
  85   1          {
  86   2          case 'l':
  87   2          case 'L':
  88   2          {
  89   3              TempData[0] = SEGNum[Data / 1000];
  90   3              TempData[1] = SEGNum[(Data % 1000) / 100];
  91   3              TempData[2] = SEGNum[((Data % 1000) % 100) / 10];
  92   3              TempData[3] = SEGNum[((Data % 1000) % 100) % 10];
  93   3              for (count = 0; count < 3 && TempData[count] == 0x3F; count++)
  94   3              {
  95   4                  TempData[count] = 0x00;
  96   4              }
  97   3              for (count = 1; count <= 4; count++)
  98   3              {
  99   4                  P1 = ~(0x01 << (8 - count));
 100   4                  P0 = ~TempData[count - 1];
 101   4                  Delay(1);
 102   4                  P0 = 0xFF;
 103   4              }
 104   3              break;
 105   3          }
 106   2          case 'r':
 107   2          case 'R':
 108   2          {
 109   3              TempData[4] = SEGNum[Data / 1000];
 110   3              TempData[5] = SEGNum[(Data % 1000) / 100];
 111   3              TempData[6] = SEGNum[((Data % 1000) % 100) / 10];
 112   3              TempData[7] = SEGNum[((Data % 1000) % 100) % 10];
 113   3              for (count = 4; count < 7 && TempData[count] == 0x3F; count++)
 114   3              {
 115   4                  TempData[count] = 0x00;
 116   4              }
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 3   

 117   3              for (count = 4; count <= 8; count++)
 118   3              {
 119   4                  P1 = ~(0x01 << (8 - count));
 120   4                  P0 = ~TempData[count - 1];
 121   4                  Delay(1);
 122   4                  P0 = 0xFF;
 123   4              }
 124   3              break;
 125   3          }
 126   2          case 'n':
 127   2          case 'N':
 128   2          {
 129   3              unsigned int Mode = 10;
 130   3              for (count = 7; count >= 0; count--)
 131   3              {
 132   4                  TempData[count] = SEGNum[Data % Mode];
 133   4                  Data = Data / 10;
 134   4              }
 135   3              for (count = 0; count < 4 && TempData[count] == 0x3F; count++)
 136   3              {
 137   4                  TempData[count] = 0x00;
 138   4              }
 139   3              for (count = 4; count < 7 && TempData[count] == 0x3F; count++)
 140   3              {
 141   4                  TempData[count] = 0x00;
 142   4              }
 143   3              for (count = 1; count <= 8; count++)
 144   3              {
 145   4                  P1 = ~(0x01 << (8 - count));
 146   4                  P0 = ~TempData[count - 1];
 147   4                  Delay(1);
 148   4                  P0 = 0xFF;
 149   4              }
 150   3              break;
 151   3          }
 152   2          }
 153   1      }
 154          
 155          /*---------------------------------------
 156          LCD1602
 157          ---------------------------------------*/
 158          //引脚配置：
 159          sbit LCD_RS = 0x90;
 160          sbit LCD_RW = 0x91;
 161          sbit LCD_EN = 0x92;
 162          #define LCD_DataPort P0
 163          
 164          //函数定义：
 165          /**
 166           * @brief  LCD1602延时函数，12MHz调用可延时1ms
 167           * @param  无
 168           * @retval 无
 169           */
 170          void LCD_Delay()
 171          {
 172   1          unsigned char i, j;
 173   1      
 174   1          i = 2;
 175   1          j = 239;
 176   1          do
 177   1          {
 178   2              while (--j)
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 4   

 179   2                  ;
 180   2          } while (--i);
 181   1      }
 182          
 183          /**
 184           * @brief  LCD1602写命令
 185           * @param  Command 要写入的命令
 186           * @retval 无
 187           */
 188          void LCD_WriteCommand(unsigned char Command)
 189          {
 190   1          LCD_RS = 0;
 191   1          LCD_RW = 0;
 192   1          LCD_DataPort = Command;
 193   1          LCD_EN = 1;
 194   1          LCD_Delay();
 195   1          LCD_EN = 0;
 196   1          LCD_Delay();
 197   1      }
 198          
 199          /**
 200           * @brief  LCD1602写数据
 201           * @param  Data 要写入的数据
 202           * @retval 无
 203           */
 204          void LCD_WriteData(unsigned char Data)
 205          {
 206   1          LCD_RS = 1;
 207   1          LCD_RW = 0;
 208   1          LCD_DataPort = Data;
 209   1          LCD_EN = 1;
 210   1          LCD_Delay();
 211   1          LCD_EN = 0;
 212   1          LCD_Delay();
 213   1      }
 214          
 215          /**
 216           * @brief  LCD1602设置光标位置
 217           * @param  Line 行位置，范围：1~2
 218           * @param  Column 列位置，范围：1~16
 219           * @retval 无
 220           */
 221          void LCD_SetCursor(unsigned char Line, unsigned char Column)
 222          {
 223   1          if (Line == 1)
 224   1          {
 225   2              LCD_WriteCommand(0x80 | (Column - 1));
 226   2          }
 227   1          else if (Line == 2)
 228   1          {
 229   2              LCD_WriteCommand(0x80 | (Column - 1 + 0x40));
 230   2          }
 231   1      }
 232          
 233          /**
 234           * @brief  LCD1602初始化函数
 235           * @param  无
 236           * @retval 无
 237           */
 238          void LCD_Init()
 239          {
 240   1          LCD_WriteCommand(0x38); //八位数据接口，两行显示，5*7点阵
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 5   

 241   1          LCD_WriteCommand(0x0c); //显示开，光标关，闪烁关
 242   1          LCD_WriteCommand(0x06); //数据读写操作后，光标自动加一，画面不动
 243   1          LCD_WriteCommand(0x01); //光标复位，清屏
 244   1      }
 245          
 246          /**
 247           * @brief  在LCD1602指定位置上显示一个字符
 248           * @param  Line 行位置，范围：1~2
 249           * @param  Column 列位置，范围：1~16
 250           * @param  Char 要显示的字符
 251           * @retval 无
 252           */
 253          void LCD_ShowChar(unsigned char Line, unsigned char Column, char Char)
 254          {
 255   1          LCD_SetCursor(Line, Column);
 256   1          LCD_WriteData(Char);
 257   1      }
 258          
 259          /**
 260           * @brief  在LCD1602指定位置开始显示所给字符串
 261           * @param  Line 起始行位置，范围：1~2
 262           * @param  Column 起始列位置，范围：1~16
 263           * @param  String 要显示的字符串
 264           * @retval 无
 265           */
 266          void LCD_ShowString(unsigned char Line, unsigned char Column, char *String)
 267          {
 268   1          unsigned char i;
 269   1          LCD_SetCursor(Line, Column);
 270   1          for (i = 0; String[i] != '\0'; i++)
 271   1          {
 272   2              LCD_WriteData(String[i]);
 273   2          }
 274   1      }
 275          
 276          /**
 277           * @brief  返回值=X的Y次方
 278           */
 279          int LCD_Pow(int X, int Y)
 280          {
 281   1          unsigned char i;
 282   1          int Result = 1;
 283   1          for (i = 0; i < Y; i++)
 284   1          {
 285   2              Result *= X;
 286   2          }
 287   1          return Result;
 288   1      }
 289          
 290          /**
 291           * @brief  在LCD1602指定位置开始显示所给数字
 292           * @param  Line 起始行位置，范围：1~2
 293           * @param  Column 起始列位置，范围：1~16
 294           * @param  Number 要显示的数字，范围：0~65535
 295           * @param  Length 要显示数字的长度，范围：1~5
 296           * @retval 无
 297           */
 298          void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 299          {
 300   1          unsigned char i;
 301   1          LCD_SetCursor(Line, Column);
 302   1          for (i = Length; i > 0; i--)
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 6   

 303   1          {
 304   2              LCD_WriteData(Number / LCD_Pow(10, i - 1) % 10 + '0');
 305   2          }
 306   1      }
 307          
 308          /**
 309           * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字
 310           * @param  Line 起始行位置，范围：1~2
 311           * @param  Column 起始列位置，范围：1~16
 312           * @param  Number 要显示的数字，范围：-32768~32767
 313           * @param  Length 要显示数字的长度，范围：1~5
 314           * @retval 无
 315           */
 316          void LCD_ShowSignedNum(unsigned char Line, unsigned char Column, int Number, unsigned char Length)
 317          {
 318   1          unsigned char i;
 319   1          unsigned int Number1;
 320   1          LCD_SetCursor(Line, Column);
 321   1          if (Number >= 0)
 322   1          {
 323   2              LCD_WriteData('+');
 324   2              Number1 = Number;
 325   2          }
 326   1          else
 327   1          {
 328   2              LCD_WriteData('-');
 329   2              Number1 = -Number;
 330   2          }
 331   1          for (i = Length; i > 0; i--)
 332   1          {
 333   2              LCD_WriteData(Number1 / LCD_Pow(10, i - 1) % 10 + '0');
 334   2          }
 335   1      }
 336          
 337          /**
 338           * @brief  在LCD1602指定位置开始以十六进制显示所给数字
 339           * @param  Line 起始行位置，范围：1~2
 340           * @param  Column 起始列位置，范围：1~16
 341           * @param  Number 要显示的数字，范围：0~0xFFFF
 342           * @param  Length 要显示数字的长度，范围：1~4
 343           * @retval 无
 344           */
 345          void LCD_ShowHexNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 346          {
 347   1          unsigned char i, SingleNumber;
 348   1          LCD_SetCursor(Line, Column);
 349   1          for (i = Length; i > 0; i--)
 350   1          {
 351   2              SingleNumber = Number / LCD_Pow(16, i - 1) % 16;
 352   2              if (SingleNumber < 10)
 353   2              {
 354   3                  LCD_WriteData(SingleNumber + '0');
 355   3              }
 356   2              else
 357   2              {
 358   3                  LCD_WriteData(SingleNumber - 10 + 'A');
 359   3              }
 360   2          }
 361   1      }
 362          
 363          /**
 364           * @brief  在LCD1602指定位置开始以二进制显示所给数字
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 7   

 365           * @param  Line 起始行位置，范围：1~2
 366           * @param  Column 起始列位置，范围：1~16
 367           * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
 368           * @param  Length 要显示数字的长度，范围：1~16
 369           * @retval 无
 370           */
 371          void LCD_ShowBinNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 372          {
 373   1          unsigned char i;
 374   1          LCD_SetCursor(Line, Column);
 375   1          for (i = Length; i > 0; i--)
 376   1          {
 377   2              LCD_WriteData(Number / LCD_Pow(2, i - 1) % 2 + '0');
 378   2          }
 379   1      }
 380          
 381          /*---------------------------------------
 382          Matrix Key
 383          ---------------------------------------*/
 384          
 385          /**
 386           * @brief 检测矩阵键盘按键
 387           * 
 388           * @return unsigned char 
 389           * @retval KeyNum 键盘号
 390           */
 391          unsigned char MatrixKey()
 392          {
 393   1          unsigned char KeyNum = 0;
 394   1      
 395   1          P2 = 0xFF;
 396   1          P2_3 = 0;
 397   1          if(P2_7 == 0)   {Delay(15); while(P2_7 == 0); Delay(15); KeyNum = 1;}
 398   1          if(P2_6 == 0)   {Delay(15); while(P2_6 == 0); Delay(15); KeyNum = 5;}
 399   1          if(P2_5 == 0)   {Delay(15); while(P2_5 == 0); Delay(15); KeyNum = 9;}
 400   1          if(P2_4 == 0)   {Delay(15); while(P2_4 == 0); Delay(15); KeyNum = 13;}
 401   1      
 402   1          P2 = 0xFF;
 403   1          P2_2 = 0;
 404   1          if(P2_7 == 0)   {Delay(15); while(P2_7 == 0); Delay(15); KeyNum = 2;}
 405   1          if(P2_6 == 0)   {Delay(15); while(P2_6 == 0); Delay(15); KeyNum = 6;}
 406   1          if(P2_5 == 0)   {Delay(15); while(P2_5 == 0); Delay(15); KeyNum = 10;}
 407   1          if(P2_4 == 0)   {Delay(15); while(P2_4 == 0); Delay(15); KeyNum = 14;}
 408   1      
 409   1          P2 = 0xFF;
 410   1          P2_1 = 0;
 411   1          if(P2_7 == 0)   {Delay(15); while(P2_7 == 0); Delay(15); KeyNum = 3;}
 412   1          if(P2_6 == 0)   {Delay(15); while(P2_6 == 0); Delay(15); KeyNum = 7;}
 413   1          if(P2_5 == 0)   {Delay(15); while(P2_5 == 0); Delay(15); KeyNum = 11;}
 414   1          if(P2_4 == 0)   {Delay(15); while(P2_4 == 0); Delay(15); KeyNum = 15;}
 415   1      
 416   1          P2 = 0xFF;
 417   1          P2_0 = 0;
 418   1          if(P2_7 == 0)   {Delay(15); while(P2_7 == 0); Delay(15); KeyNum = 4;}
 419   1          if(P2_6 == 0)   {Delay(15); while(P2_6 == 0); Delay(15); KeyNum = 8;}
 420   1          if(P2_5 == 0)   {Delay(15); while(P2_5 == 0); Delay(15); KeyNum = 12;}
 421   1          if(P2_4 == 0)   {Delay(15); while(P2_4 == 0); Delay(15); KeyNum = 16;}
 422   1      
 423   1          return KeyNum;
 424   1      }
 425          
 426          /*---------------------------------------
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 8   

 427          Key
 428          ---------------------------------------*/
 429          
 430          /**
 431           * @brief 获取独立按键键盘码
 432           * @retval 键盘号 范围：0~4
 433           * @return unsigned char 
 434           */
 435          unsigned char Key()
 436          {
 437   1          unsigned char KeyNum = 0;
 438   1      
 439   1          if(P2_3 == 0)   {Delay(20); while(P2_3 == 0); Delay(20); KeyNum = 1;}
 440   1          if(P2_2 == 0)   {Delay(20); while(P2_2 == 0); Delay(20); KeyNum = 2;}
 441   1          if(P2_1 == 0)   {Delay(20); while(P2_1 == 0); Delay(20); KeyNum = 3;}
 442   1          if(P2_0 == 0)   {Delay(20); while(P2_0 == 0); Delay(20); KeyNum = 4;}
 443   1      
 444   1          return KeyNum;
 445   1      }
 446          
 447          /*---------------------------------------
 448          Timer0 Init
 449          ---------------------------------------*/
 450          /**
 451           * @brief 定时器器0函数初始化函数，12MHz
 452           * @retval 无
 453           */
 454          void Timer0_Init(void)    //1毫秒@12.000MHz
 455          {
 456   1        TMOD &= 0xF0;   //设置定时器模式
 457   1        TMOD |= 0x01;   //设置定时器模式
 458   1        TL0 = 0x18;   //设置定时初始值
 459   1        TH0 = 0xFC;   //设置定时初始值
 460   1        TF0 = 0;    //清除TF0标志
 461   1        TR0 = 1;    //定时器0开始计时
 462   1          ET0 = 1;        //设置中断标志
 463   1          EA = 1;
 464   1          PT0 = 0;
 465   1      }
 466          /*
 467          1s计时器中断函数模板
 468          
 469          void Timer0_Routine() interrupt 1
 470          {
 471              static unsigned int T0_Count = 0;
 472              TL0 = 0x18;
 473              TH0 = 0xFC;
 474              T0_Count++;
 475              if (T0_Count >= 1000)
 476              {
 477                  T0_Count = 0;
 478                  P0_0 = ~P0_0;
 479              }
 480          }
 481          */
 482          
 483          /*---------------------------------------
 484          Serial Ports
 485          ---------------------------------------*/
 486          
 487          /**
 488           * @brief 初始化串口(4800bps)
C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 9   

 489           * 
 490           */
 491          
 492          void Uart_Init(void)    //4800bps@12.000MHz
 493          {
 494   1        PCON |= 0x80;   //使能波特率倍速位SMOD
 495   1        SCON = 0x50;    //8位数据,可变波特率
 496   1        TMOD &= 0x0F;   //设置定时器模式
 497   1        TMOD |= 0x20;   //设置定时器模式
 498   1        TL1 = 0xF3;   //设置定时初始值
 499   1        TH1 = 0xF3;   //设置定时重载值
 500   1        ET1 = 0;    //禁止定时器1中断
 501   1        TR1 = 1;    //定时器1开始计时
 502   1          EA = 1;         //中断设置
 503   1          ES = 1;
 504   1      }
 505          
 506          // /**
 507          //  * @brief 初始化串口(可接收)
 508          //  * 
 509          //  * @param MODE 重载时标志参数
 510          //  */
 511          // void Uart_Init(unsigned int MODE)
 512          // {
 513          //     PCON |= 0x80;    //使能波特率倍速位SMOD
 514          //  SCON = 0x50;    //8位数据,可变波特率
 515          //  TMOD &= 0x0F;   //设置定时器模式
 516          //  TMOD |= 0x20;   //设置定时器模式
 517          //  TL1 = 0xF3;   //设置定时初始值
 518          //  TH1 = 0xF3;   //设置定时重载值
 519          //  ET1 = 0;    //禁止定时器1中断
 520          //  TR1 = 1;    //定时器1开始计时
 521          //     EA = 1;
 522          //     ES = 1;
 523          // }
 524          
 525          /**
 526           * @brief 向电脑发送数据
 527           * 
 528           * @param Byte 所发送的1Byte数据
 529           * @retval 无
 530           */
 531          void Uart_SendByte(unsigned char Byte)
 532          {
 533   1          SBUF = Byte;
 534   1          while (TI == 0);
 535   1          TI = 0;     //TI软件复位
 536   1      }
 537          
 538          /*串口控制LED样例
 539          void UART_Routine() interrupt 4
 540          {
 541              if(RI == 1)
 542              {
 543                  P0 = ~SBUF;
 544                  Uart_SendByte(SBUF);
 545                  RI = 0;         //RI软件复位
 546              }
 547          }
 548          */


C51 COMPILER V9.60.0.0   BASICALFUNC                                                       01/18/2022 15:13:40 PAGE 10  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1623    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      41
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
